let getParam,getOpen,getValues,isOnly,formatUpdate,formatSolution;_c64‍.x([["default",()=>solveSingleParam]]);_c64‍.w("../cellPath",[["getParam",["getParam"],function(v){getParam=v}],["getOpen",["getOpen"],function(v){getOpen=v}],["getValues",["getValues"],function(v){getValues=v}]]);_c64‍.w("../solutionObject",[["isOnly",["isOnly"],function(v){isOnly=v}],["formatUpdate",["formatUpdate"],function(v){formatUpdate=v}],["formatSolution",["formatSolution"],function(v){formatSolution=v}]]);











// 2. Solves cell by recognizing only one option left in a single parameter
// Ex: only one answer possible in row
               function solveSingleParam(sudokuGrid, gridParam) {
    const paramUsed = getParam(gridParam);
    if (!paramUsed) {
      return false;
    }
    const openGrid = getOpen(gridParam, sudokuGrid);
    const allValues = getValues(openGrid, sudokuGrid).flat();
    const singleValuesFound = [...new Set(allValues)]
        .filter(x => allValues.indexOf(x) === allValues.lastIndexOf(x));
    if (singleValuesFound.length === 0) {
      return false;
    }
    const indexFound = singleValuesFound
        .map(val => openGrid.find(x => sudokuGrid[x].includes(val)) );
    const updates = singleValuesFound.map( (val, i) => 
        formatUpdate(indexFound[i], sudokuGrid, isOnly(val)) );
    const solutionList = indexFound.map( (cellFound, i) => 
        formatSolution(`singleParam-${paramUsed}`, cellFound, updates[i]));
    return solutionList;
  };